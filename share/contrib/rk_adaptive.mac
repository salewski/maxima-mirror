rk_adaptive(expr,vars,vars_initval,var,startval,endval,[params]):=block(
    [
        result,
        point,
        offset_1step,
        offset_2steps,
        time:startval,
        timestep:float((endval-startval)/1000),
        abserr,
        maxabserr:1e-6,
        maxstep:(endval-startval)/100,
        minstep:(endval-startval)/1000000,
        sgn,
        nexttime,
        minstepwarn:false
    ],
    for i in params do
    (
        if lhs(i)='maxstep then maxstep:rhs(i) else
        if lhs(i)='minstep then minstep:rhs(i) else
        if lhs(i)='timestep_initial then timestep:rhs(i) else
        if lhs(i)='maxerr then maxabserr:rhs(i) else
        warning("rk_adaptive: Found a unknown param")
    ),
    if maxabserr <= 0 then error("rk_adaptive: Illegal value for maxerr"),
    if maxstep <= 0 then error("rk_adaptive: Illegal value for maxstep"),
    if minstep <= 0 then error("rk_adaptive: Illegal value for minstep"),
    if timestep_initial = 0 then error("rk_adaptive: Illegal value for timestep_initial"),
    /* Do we need to reverse some comparisons since the time we end is before the time we start at? */
    if endval >= startval then sgn:1 else sgn:-1,
    /* Make sure our first 3 arguments are lists */
    if not listp(expr) then expr:[expr],
    if not listp(vars) then vars:[vars],
    if not listp(vars_initval) then vars_initval:[vars_initval],
    point:vars_initval,
    result:[append([startval],vars_initval)],
    do (
        do (
            /* Calculate the next 2 points */
            offset_1step:sgn*subst(var=time+timestep,
                subst(map("=",vars,point),expr)
            )*timestep,
            offset_2steps:offset_1step+sgn*subst(var=time+timestep*2,
                subst(map("=",vars,point+offset_1step),expr)
            )*timestep,
            /* Calculate the error */
            abserr:apply('max,cabs(2*offset_1step-offset_2steps)),
            /* Save the time offset_1step is at */
            nexttime:time+timestep,
            /* See if we should adjust the time step width */
            if abserr>maxabserr then
                timestep:sgn*max(sgn*timestep/2,sgn*minstep)
            else if abserr<1/4*maxabserr then
                timestep:sgn*min(maxstep*sgn,timestep*2),

            if timestep=minstep then
            (
                minstepwarn:true,
                return()
            ),
            if abserr<=maxabserr then return()
        ),
        time:nexttime,
        push(append([time],point+offset_1step),result),
        point:point+offset_1step,
        if sgn*time>sgn*endval then return()
    ),
    if minstepwarn = true then warning("rk_adaptive: Didn't meet the tolerance goal."),
    args(transpose(apply('matrix,reverse(result))))
);